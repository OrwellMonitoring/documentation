"use strict";(self.webpackChunkorwell_docs=self.webpackChunkorwell_docs||[]).push([[53],{1109:function(e){e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Intro","href":"/documentation/","docId":"intro"},{"type":"link","label":"Architecture","href":"/documentation/architecture","docId":"architecture"},{"type":"category","label":"Orwell Core","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Orwell API","href":"/documentation/core/api","docId":"core/api"},{"type":"link","label":"SD Configuration","href":"/documentation/core/service-discovery","docId":"core/service-discovery"},{"type":"link","label":"Gnocchi Puller","href":"/documentation/core/gnocchi-puller","docId":"core/gnocchi-puller"}]},{"type":"category","label":"Deployment","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"System Agents","href":"/documentation/deployment/system-agents","docId":"deployment/system-agents"}]},{"type":"category","label":"Security","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Suricata","href":"/documentation/security/suricata","docId":"security/suricata"},{"type":"link","label":"Infection Monkey","href":"/documentation/security/infection-monkey","docId":"security/infection-monkey"}]},{"type":"category","label":"Metrics Collection","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"How to create an OS boot service","href":"/documentation/metrics-export/create-os-boot-service","docId":"metrics-export/create-os-boot-service"}]},{"type":"link","label":"Python Package","href":"/documentation/pythonPackage","docId":"pythonPackage"},{"type":"link","label":"Metrics Translators","href":"/documentation/translators","docId":"translators"}]},"docs":{"architecture":{"id":"architecture","title":"Architecture","description":"Our system has a microservices architecture, based in several independent modules that work together.","sidebar":"tutorialSidebar"},"core/api":{"id":"core/api","title":"Orwell API","description":"","sidebar":"tutorialSidebar"},"core/gnocchi-puller":{"id":"core/gnocchi-puller","title":"Gnocchi Puller","description":"","sidebar":"tutorialSidebar"},"core/service-discovery":{"id":"core/service-discovery","title":"SD Configuration","description":"","sidebar":"tutorialSidebar"},"deployment/system-agents":{"id":"deployment/system-agents","title":"System Agents","description":"ORWELL\'s main lifecycle depends on the communication of three big layers: the Storage/Visualization layer, the Middleware layer and the Translators layer. The deployment process revolves around containerizing the components that form each layer, providing a configurable environment for easy integration and adaptation to infrastructure changes.","sidebar":"tutorialSidebar"},"intro":{"id":"intro","title":"Intro","description":"5G networks are fiercely developing and so are the vertical applications of this technology, in fields such as Automotive, 4.0 Industry or Public Protection and Disaster Relief. To develop new 5G applications, researchers need to test them. However, the price of 5G infrasctructure and the required expertise to assemble a fully functional testbed may be a barrier that some cannot overcome. This led to the creation of 5G testbeds with state-of-the-art technology which allow NetApp developers to have access to the required infrastructure to test their applications without having to worry about all the deployment process. These tests require a controlled environment, thus all the infrastructure has to be monitored. This work discusses an approach that complies with 5GASP directives and centralizes all the information on a unique time-series database. Moreover, the proposed methodologies were implemented in a proof of concept product which demonstrates the potential of the proposed approach on a working testbed.","sidebar":"tutorialSidebar"},"metrics-export/create-os-boot-service":{"id":"metrics-export/create-os-boot-service","title":"How to create an OS boot service","description":"Introduction","sidebar":"tutorialSidebar"},"pythonPackage":{"id":"pythonPackage","title":"Python Package","description":"About","sidebar":"tutorialSidebar"},"security/infection-monkey":{"id":"security/infection-monkey","title":"Infection Monkey","description":"Infection Monkey is a network breaching simulation tool which finds and reports flaws and exploits in the nodes of a network. A guide to setup an Infection Monkey server can be found here","sidebar":"tutorialSidebar"},"security/suricata":{"id":"security/suricata","title":"Suricata","description":"Suricata\xa0is a Network Security Monitoring (NSM) tool that uses sets of community created and user defined signatures (also referred to as rules) to examine and process network traffic. Suricata can generate log events, trigger alerts, and drop traffic when it detects suspicious packets or requests to any number of different services running on a server.","sidebar":"tutorialSidebar"},"translators":{"id":"translators","title":"Metrics Translators","description":"This repository holds all the different translator scripts built for reading different Kafka topics and outputing valid Prometheus format.","sidebar":"tutorialSidebar"}}}')}}]);